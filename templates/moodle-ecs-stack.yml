---
AWSTemplateFormatVersion: '2010-09-09'

Description: A stack for deploying containerized applications onto a cluster of EC2 hosts using Elastic Container Service. 
             This stack runs containers on hosts that are in a private VPC subnet. 
             Outbound network traffic from the hosts must go out through a NAT gateway. 
             There is one load balancer inside the public subnet, which can be used to send traffic to the containers in the private subnet. 
             https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/ECS/EC2LaunchType/clusters/private-vpc.yml

Parameters:
  env:
    Description: Environment name to provision resources
    Type: String
    AllowedValues: ["dev", "prod"]
    Default: dev
  project:
    Description: Project name to provision resources
    Type: String
    Default: moodle

  # parameters for ecs
  DesiredCapacity:
    Type: Number
    Default: '1'
    Description: Number of EC2 instances to launch in your ECS cluster.
  MaxSize:
    Type: Number
    Default: '2'
    Description: Maximum number of EC2 instances that can be launched in your ECS cluster.
  ECSAMI:
    Description: AMI ID
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id
  InstanceType:
    Description: EC2 instance type
    Type: String
    Default: t3.nano
    AllowedValues: [t3.nano, t3.micro, t3.small, t3.medium, t3.large, t3.xlarge, t3.2xlarge, 
                    m4.large, m4.xlarge, m4.2xlarge, m4.4xlarge, m4.10xlarge, 
                    c4.large, c4.xlarge, c4.2xlarge, c4.4xlarge, c4.8xlarge, 
                    r3.large, r3.xlarge, r3.2xlarge, r3.4xlarge, r3.8xlarge, 
                    i2.xlarge, i2.2xlarge, i2.4xlarge, i2.8xlarge]
    ConstraintDescription: Please choose a valid instance type.

  # parameters for bastion host
  ImageId:
    Description: moodle bastion host AMI ID 
    Type: String
    Default: ami-08fdde86b93accf1c
  KeyName:
    Description: EC2 instance key name
    Type: String
    Default: moodle-keypair
  InstanceType:
    Description: EC2 instance type
    Type: String
    Default: t3.nano
  SSHLocation:
    Description: ip address allowed to ssh login bastion host, use command 'curl checkip.amazonaws.com' to get your Internet facing ip address
    Type: String
    Default: '123.243.138.223/32'

Mappings:
  # Hard values for the subnet masks, both dev and prod environment. 
  # These masks define the range of internal IP addresses that can be assigned.
  # The VPC can have all IP's from 10.0.0.0 to 10.0.255.255
  # There are ten subnets which cover the ranges:
  #
  # 10.10.10.0 - 10.10.10.255
  # 10.10.11.0 - 10.10.11.255
  # 10.10.12.0 - 10.10.12.255
  # 10.10.13.0 - 10.10.13.255
  # 10.11.20.0 - 10.11.20.255
  # 10.11.21.0 - 10.11.21.255
  # 10.11.22.0 - 10.11.22.255
  # 10.11.23.0 - 10.11.23.255
  #
  # If you need more IP addresses (perhaps you have so many
  # instances that you run out) then you can customize these
  # ranges to add more
  vpcCIDR:
    dev: 
      CIDR: "10.10.0.0/16"
    prod: 
      CIDR: "10.11.0.0/16"
  PublicSubnet1CIDR: 
    dev: 
      CIDR: "10.10.10.0/24"
    prod: 
      CIDR: "10.11.20.0/24"
  PublicSubnet2CIDR:
    dev: 
      CIDR: "10.10.12.0/24"
    prod: 
      CIDR: "10.11.22.0/24"
  PrivateSubnet1CIDR: 
    dev: 
      CIDR: "10.10.11.0/24"
    prod: 
      CIDR: "10.11.21.0/24"
  PrivateSubnet2CIDR:
    dev: 
      CIDR: "10.10.13.0/24"
    prod: 
      CIDR: "10.11.23.0/24"

Resources:
  # VPC in which containers will be networked.
  # It has two public subnets, and two private subnets.
  # We distribute the subnets across the first two available subnets
  # for the region, for high availability.
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true
      CidrBlock: !FindInMap [vpcCIDR, !Ref env, CIDR]
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'vpc' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

  # Two public subnets, where containers can have public IP addresses
  PublicSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 0
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap [PublicSubnet1CIDR, !Ref env, CIDR]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PublicSubnetOne' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PublicSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 1
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap [PublicSubnet2CIDR, !Ref env, CIDR]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PublicSubnetTwo' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

  # Two private subnets where containers will only have private
  # IP addresses, and will only be reachable by other members of the
  # VPC
  PrivateSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 0
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap [PrivateSubnet1CIDR, !Ref env, CIDR]
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PrivateSubnetOne' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PrivateSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 1
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'VPC'
      CidrBlock: !FindInMap [PrivateSubnet2CIDR, !Ref env, CIDR]
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PrivateSubnetTwo' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  
  # Setup networking resources for the public subnets. Containers
  # in the public subnets have public IP addresses and the routing table
  # sends network traffic via the internet gateway.
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties: 
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'InternetGateway' ] ]  
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  GatewayAttachement:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PublicRouteTable' ] ]  
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachement
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnetOneRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetOne
      RouteTableId: !Ref PublicRouteTable
  PublicSubnetTwoRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetTwo
      RouteTableId: !Ref PublicRouteTable

  # Setup networking resources for the private subnets. Containers
  # in these subnets have only private IP addresses, and must use a NAT
  # gateway to talk to the internet. We launch two NAT gateways, one for
  # each private subnet.
  NatGatewayOneAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachement
    Properties:
      Domain: vpc
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'NatGatewayOneAttachment' ] ]  
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  NatGatewayTwoAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachement
    Properties:
      Domain: vpc
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'NatGatewayTwoAttachment' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  NatGatewayOne:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayOneAttachment.AllocationId
      SubnetId: !Ref PublicSubnetOne
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'NatGatewayOne' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  NatGatewayTwo:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayTwoAttachment.AllocationId
      SubnetId: !Ref PublicSubnetTwo
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'NatGatewayTwo' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PrivateRouteTableOne:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PrivateRouteTableOne' ] ]  
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PrivateRouteOne:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableOne
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayOne
  PrivateRouteTableOneAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTableOne
      SubnetId: !Ref PrivateSubnetOne
  PrivateRouteTableTwo:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PrivateRouteTableTwo' ] ]  
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PrivateRouteTwo:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableTwo
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayTwo
  PrivateRouteTableTwoAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTableTwo
      SubnetId: !Ref PrivateSubnetTwo

  # ECS Resources
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'ECSCluster' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

  # A security group for the EC2 hosts that will run the containers.
  # Two rules, allowing network traffic from a public facing load
  # balancer and from other hosts in the security group.
  #
  # Remove any of the following ingress rules that are not needed.
  # If you want to make direct requests to a container using its
  # public IP address you'll need to add a security group rule
  # to allow traffic from all IP addresses.
  EcsHostSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the ECS hosts that run containers
      VpcId: !Ref 'VPC'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'EcsHostSecurityGroup' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  EcsSecurityGroupIngressFromPublicALB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the public ALB
      GroupId: !Ref 'EcsHostSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'PublicLoadBalancerSG'
  EcsSecurityGroupIngressFromSelf:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from other containers in the same security group
      GroupId: !Ref 'EcsHostSecurityGroup'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref 'EcsHostSecurityGroup'
  EcsSecurityGroupIngressFromBastionHost:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the bastion host
      GroupId: !Ref EcsHostSecurityGroup
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22
      SourceSecurityGroupId: !Ref BastionHostSecurityGroup

  # Autoscaling group. This launches the actual EC2 instances that will register
  # themselves as members of the cluster, and run the docker containers.
  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo
      LaunchConfigurationName: !Ref 'ContainerInstances'
      MinSize: '1'
      MaxSize: !Ref 'MaxSize'
      DesiredCapacity: !Ref 'DesiredCapacity'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'ECSAutoScalingGroup' ] ]
          PropagateAtLaunch: true
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
          PropagateAtLaunch: true
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'
  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !Ref 'ECSAMI'
      KeyName: !Ref 'KeyName'
      SecurityGroups: [!Ref 'EcsHostSecurityGroup']
      InstanceType: !Ref 'InstanceType'
      IamInstanceProfile: !Ref 'EC2InstanceProfile'
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - 'application-autoscaling:*'
              - 'cloudwatch:DescribeAlarms'
              - 'cloudwatch:PutMetricAlarm'
              - 'ecs:DescribeServices'
              - 'ecs:UpdateService'
            Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'AutoscalingRole' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']

  # Role for the EC2 hosts. This allows the ECS agent on the EC2 hosts
  # to communciate with the ECS control plane, as well as download the docker
  # images from ECR to run on your host.
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - 'ecs:CreateCluster'
              - 'ecs:DeregisterContainerInstance'
              - 'ecs:DiscoverPollEndpoint'
              - 'ecs:Poll'
              - 'ecs:RegisterContainerInstance'
              - 'ecs:StartTelemetrySession'
              - 'ecs:Submit*'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
              - 'ecr:GetAuthorizationToken'
              - 'ecr:BatchGetImage'
              - 'ecr:GetDownloadUrlForLayer'
            Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'EC2Role' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  # Load balancers for getting traffic to containers. This sample template creates one load balancer hosted in public subnets that is accessible
  # to the public, and is intended to route traffic to one or more public facing services.

  # A public facing load balancer, this is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancerSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the public facing load balancer
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        # Allow access to ALB from anywhere on the internet
        - CidrIp: 0.0.0.0/0
          IpProtocol: -1
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PublicLoadBalancerSG' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
      - Key: idle_timeout.timeout_seconds
        Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
      SecurityGroups: [!Ref 'PublicLoadBalancerSG']
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'PublicLoadBalancer' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

  # A dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !Join ['-', [!Ref 'AWS::StackName', 'drop-1']]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !Ref 'VPC'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'DummyTargetGroupPublic' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicLoadBalancer
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref 'DummyTargetGroupPublic'
          Type: 'forward'
      LoadBalancerArn: !Ref 'PublicLoadBalancer'
      Port: 80
      Protocol: HTTP

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Rules which allow ECS to attach network interfaces to instances
                # on your behalf in order for awsvpc networking mode to work right
                - 'ec2:AttachNetworkInterface'
                - 'ec2:CreateNetworkInterface'
                - 'ec2:CreateNetworkInterfacePermission'
                - 'ec2:DeleteNetworkInterface'
                - 'ec2:DeleteNetworkInterfacePermission'
                - 'ec2:Describe*'
                - 'ec2:DetachNetworkInterface'
  
                # Rules which allow ECS to update load balancers on your behalf
                # with the information sabout how to send traffic to your containers
                - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                - 'elasticloadbalancing:DeregisterTargets'
                - 'elasticloadbalancing:Describe*'
                - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                - 'elasticloadbalancing:RegisterTargets'
              Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'ECSRole' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

  BastionHostSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Allow ssh login to the bastion host
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'BastionHostSecurityGroup' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'
  BastionHostSecurityGroupIngressFromInternet:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the Internet
      GroupId: !Ref BastionHostSecurityGroup
      CidrIp: !Ref SSHLocation
      IpProtocol: tcp
      FromPort: 22
      ToPort: 22

  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      KeyName: !Ref KeyName
      InstanceType: !Ref InstanceType
      SubnetId: !Ref 'PublicSubnetOne'
      SecurityGroupIds: 
        - !Ref 'BastionHostSecurityGroup'
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          yum update -y
          yum install -y mariadb
          yum install -y nfs-utils
          systemctl start nfs
          systemctl enable nfs
      Tags: 
        - Key: Name
          Value: !Join [ '-', [ !Ref 'project', !Ref 'env', 'BastionHost' ] ]
        - Key: Createdby
          Value: !Ref 'AWS::StackName'

# These are the values output by the CloudFormation template. Be careful
# about changing any of them, because of them are exported with specific
# names so that the other task related CF templates can use them.
Outputs:
  ClusterName:
    Description: The name of the ECS cluster
    Value: !Ref 'ECSCluster'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ClusterName' ] ]
  ExternalUrl:
    Description: The url of the external load balancer
    Value: !Join ['', ['http://', !GetAtt 'PublicLoadBalancer.DNSName']]
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ExternalUrl' ] ]
  ECSRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'ECSRole.Arn'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ECSRole' ] ]
  PublicListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref PublicLoadBalancerListener
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PublicListener' ] ]
  VPCId:
    Description: The ID of the VPC that this stack is deployed in
    Value: !Ref 'VPC'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'VPCId' ] ]
  PublicSubnetOne:
    Description: Public subnet one
    Value: !Ref 'PublicSubnetOne'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PublicSubnetOne' ] ]
  PublicSubnetTwo:
    Description: Public subnet two
    Value: !Ref 'PublicSubnetTwo'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PublicSubnetTwo' ] ]
  PrivateSubnetOne:
    Description: Private subnet one
    Value: !Ref 'PrivateSubnetOne'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PrivateSubnetOne' ] ]
  PrivateSubnetTwo:
    Description: Private subnet two
    Value: !Ref 'PrivateSubnetTwo'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PrivateSubnetTwo' ] ]
  EcsHostSecurityGroup:
    Description: A security group used to allow containers to receive traffic
    Value: !Ref 'EcsHostSecurityGroup'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'EcsHostSecurityGroup' ] ]
  BastionHostPublicIP:
    Description: The PublicIP of the bastion host
    Value: !GetAtt BastionHost.PublicIp
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'BastionHostPublicIP' ] ]
  BastionHostInstanceId:
    Description: The InstanceId of the bastion host
    Value: !Ref BastionHost
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'BastionHostInstanceId' ] ]
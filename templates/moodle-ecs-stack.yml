---
AWSTemplateFormatVersion: '2010-09-09'

Metadata: 
  License: Apache-2.0

Description: "This stack create ecs cluster, auto scaling group and efs for moodle infrastructure."

Parameters:
  env:
    Description: Environment name to provision resources
    Type: String
    AllowedValues: ["dev", "prod"]
    Default: dev
  VpcStackName:
    Description: moodle ecs stack to deploy this service stack
    Type: String
    AllowedValues: ["moodle-vpc-stack-dev", "moodle-vpc-stack-prod"]
    Default: moodle-vpc-stack-dev

  DesiredCapacity:
    Type: Number
    Default: '1'
    Description: Number of EC2 instances to launch in your ECS cluster.
  MaxSize:
    Type: Number
    Default: '2'
    Description: Maximum number of EC2 instances that can be launched in your ECS cluster.
  ECSAMI:
    Description: AMI ID
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id
  KeyName:
    Description: EC2 instance key name
    Type: String
    Default: moodle-keypair
  InstanceType:
    Description: EC2 instance type
    Type: String
    Default: t3.micro
    AllowedValues: [t3.micro, t3.small, t3.medium, t3.large, m3.medium, m3.large,
      m3.xlarge, m3.2xlarge, m4.large, m4.xlarge, m4.2xlarge, m4.4xlarge, m4.10xlarge,
      c4.large, c4.xlarge, c4.2xlarge, c4.4xlarge, c4.8xlarge, c3.large, c3.xlarge,
      c3.2xlarge, c3.4xlarge, c3.8xlarge, r3.large, r3.xlarge, r3.2xlarge, r3.4xlarge,
      r3.8xlarge, i2.xlarge, i2.2xlarge, i2.4xlarge, i2.8xlarge]
    ConstraintDescription: Please choose a valid instance type.

  MountPoint:
    Description: The ecs container instances mount point for the EFS volume
    Type: String
    Default: MoodleDataVolumeEFS

  ImageUrl:
    Type: String
    Default: nginx
    Description: The url of a docker image that contains the application process that will handle the traffic for this service
  ContainerCpu:
    Type: Number
    Default: 256
    Description: How much CPU to give the container. 1024 is 1 CPU
  ContainerMemory:
    Type: Number
    Default: 512
    Description: How much memory in megabytes to give the container
  ContainerPort:
    Type: Number
    Default: 80
    Description: What port number the application inside the docker container is binding to

  DesiredCount:
    Type: Number
    Default: 1
    Description: How many copies of the service task to run

  Path:
    Type: String
    Default: "*"
    Description: A path on the public load balancer that this service 
                 should be connected to. Use * to send all load balancer
                 traffic to this service.
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer.
                 This only applies if your have multiple services which have been
                 assigned to different paths on the load balancer.

  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the service's containers if the code within needs to
                 access other AWS resources like S3 buckets, DynamoDB tables, etc
  
Conditions:
  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]

Mappings: 
  EcsName: 
    dev: 
      Name: "moodle-dev-ecs"
    prod: 
      Name: "moodle-prod-ecs"
  VolumeName:
    dev: 
      Name: "moodle-dev-efs-vol"
    prod: 
      Name: "moodle-prod-efs-vol"
  ServiceName: 
    dev: 
      Name: "moodle-service-stack-dev"
    prod: 
      Name: "moodle-service-stack-prod"

Resources:
  # ECS Resources
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      Tags:
        - Key: Name
          Value: !FindInMap [EcsName, !Ref env, Name]
        - Key: Project
          Value: moodle
        - Key: Createdby
          Value: fen9li
        - Key: ChargeTo
          Value: !Ref env

  # EFS resource
  MountTargetSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId:
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'VPCId']]
      GroupDescription: Security group for mount target
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'MountTargetSecurityGroup' ] ]
  MountTargetSecurityGroupIngressFromBastionHost:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the bastion host
      GroupId: !Ref MountTargetSecurityGroup
      IpProtocol: tcp
      FromPort: 2049
      ToPort: 2049
      SourceSecurityGroupId: 
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'BastionHostSecurityGroup']]
  MountTargetSecurityGroupIngressFromEcsHost:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress from the ecs hosts
      GroupId: !Ref MountTargetSecurityGroup
      IpProtocol: tcp
      FromPort: 2049
      ToPort: 2049
      SourceSecurityGroupId: 
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'EcsHostSecurityGroup']]

  FileSystem:
    Type: AWS::EFS::FileSystem
    Properties:
      PerformanceMode: generalPurpose
      FileSystemTags:
      - Key: Name
        Value: !FindInMap [VolumeName, !Ref env, Name]
      - Key: Project
        Value: moodle
      - Key: Createdby
        Value: fen9li
      - Key: ChargeTo
        Value: !Ref env
  MountTargetOne:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId:
        Ref: FileSystem
      SubnetId: 
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetOne']]
      SecurityGroups:
        - !Ref MountTargetSecurityGroup
  MountTargetTwo:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId:
        Ref: FileSystem
      SubnetId: 
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetTwo']]
      SecurityGroups:
        - !Ref MountTargetSecurityGroup

  # Autoscaling group. This launches the actual EC2 instances that will register
  # themselves as members of the cluster, and run the docker containers.
  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn:
    - MountTargetOne
    - MountTargetTwo
    Properties:
      VPCZoneIdentifier:
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetOne']]
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetTwo']]
      LaunchConfigurationName: !Ref ContainerInstances
      MinSize: '1'
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'
  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !Ref ECSAMI
      KeyName: !Ref KeyName
      SecurityGroups: 
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'EcsHostSecurityGroup']]
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref EC2InstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe

          yum install -y nfs-utils
          systemctl start nfs
          systemctl enable nfs

          yum install -y amazon-efs-utils
          mkdir /mnt/efs
          mount -t efs ${FileSystem}:/ /mnt/efs

          echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - 'application-autoscaling:*'
              - 'cloudwatch:DescribeAlarms'
              - 'cloudwatch:PutMetricAlarm'
              - 'ecs:DescribeServices'
              - 'ecs:UpdateService'
            Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'ContainerLaunchConfiguration' ] ]
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref EC2Role]
    
  # Role for the EC2 hosts. This allows the ECS agent on the EC2 hosts
  # to communciate with the ECS control plane, as well as download the docker
  # images from ECR to run on your host.
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                - 'ecs:CreateCluster'
                - 'ecs:DeregisterContainerInstance'
                - 'ecs:DiscoverPollEndpoint'
                - 'ecs:Poll'
                - 'ecs:RegisterContainerInstance'
                - 'ecs:StartTelemetrySession'
                - 'ecs:Submit*'
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchGetImage'
                - 'ecr:GetDownloadUrlForLayer'
              Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'EC2Role' ] ]


  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !FindInMap [ServiceName, !Ref env, Name]
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      TaskRoleArn:
        Fn::If:
          - 'HasCustomRole'
          - !Ref 'Role'
          - !Ref "AWS::NoValue"
      ContainerDefinitions:
        - Name: !FindInMap [ServiceName, !Ref env, Name]
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          PortMappings:
            - 
              ContainerPort: !Ref 'ContainerPort'
              Protocol: tcp
  
  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: !FindInMap [ServiceName, !Ref env, Name]
      Cluster: !Ref 'ECSCluster'
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !FindInMap [ServiceName, !Ref env, Name]
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn: !Ref 'TargetGroup'

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Name: !FindInMap [ServiceName, !Ref env, Name]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue:
          !Join ['-', [!Ref 'VpcStackName', 'VPCId']]

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref 'TargetGroup'
          Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn: !Ref 'PublicLoadBalancerListener'
      Priority: !Ref 'Priority'

  # Load balancers for getting traffic to containers.
  # This sample template creates two load balancers:
  #
  # - One public load balancer, hosted in public subnets that is accessible
  #   to the public, and is intended to route traffic to one or more public
  #   facing services.
  # - One private load balancer, hosted in private subnets, that only
  #   accepts traffic from other containers in the cluster, and is
  #   intended for private services that should not be accessed directly
  #   by the public.

  # A public facing load balancer, this is used for accepting traffic from the public
  # internet and directing it to public facing microservices
  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: '30'
      Subnets:
        # The load balancer is placed into the public subnets, so that traffic
        # from the internet can reach the load balancer directly via the internet gateway
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetOne']]
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'PrivateSubnetTwo']]
      SecurityGroups: 
        - Fn::ImportValue: 
            !Join ['-', [!Ref 'VpcStackName', 'PublicLoadBalancerSG']]
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'PublicLoadBalancer' ] ]

  # A dummy target group is used to setup the ALB to just drop traffic
  # initially, before any real service target groups have been added.
  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 6
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: 
        Fn::ImportValue: 
          !Join ['-', [!Ref 'VpcStackName', 'VPCId']]
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'DummyTargetGroupPublic' ] ]

  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicLoadBalancer
    Properties:
      DefaultActions:
        - Type: 'forward'
          #TargetGroupArn: !Ref 'DummyTargetGroupPublic'
          TargetGroupArn: !Ref 'TargetGroup'
      LoadBalancerArn: !Ref 'PublicLoadBalancer'
      Port: 80
      Protocol: HTTP

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  ECSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: ecs-service
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Rules which allow ECS to attach network interfaces to instances
                # on your behalf in order for awsvpc networking mode to work right
                - 'ec2:AttachNetworkInterface'
                - 'ec2:CreateNetworkInterface'
                - 'ec2:CreateNetworkInterfacePermission'
                - 'ec2:DeleteNetworkInterface'
                - 'ec2:DeleteNetworkInterfacePermission'
                - 'ec2:Describe*'
                - 'ec2:DetachNetworkInterface'
  
                # Rules which allow ECS to update load balancers on your behalf
                # with the information sabout how to send traffic to your containers
                - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
                - 'elasticloadbalancing:DeregisterTargets'
                - 'elasticloadbalancing:Describe*'
                - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
                - 'elasticloadbalancing:RegisterTargets'
              Resource: '*'
      Tags:
        - Key: Name
          Value: !Join [ '-', [ !Ref env , 'ECSRole' ] ]
# These are the values output by the CloudFormation template. Be careful
# about changing any of them, because of them are exported with specific
# names so that the other task related CF templates can use them.
Outputs:
  StackName:
    Description: The name of this stack
    Value: !Ref 'AWS::StackName'
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'StackName' ] ]
  ClusterName:
    Description: The name of the ECS cluster
    Value: !Ref 'ECSCluster'
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'ClusterName' ] ]
  ExternalUrl:
    Description: The url of the external load balancer
    Value: !Join ['', ['http://', !GetAtt 'PublicLoadBalancer.DNSName']]
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'ExternalUrl' ] ]
  ECSRole:
    Description: The ARN of the ECS role
    Value: !GetAtt 'ECSRole.Arn'
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'ECSRole' ] ]
  PublicListener:
    Description: The ARN of the public load balancer's Listener
    Value: !Ref PublicLoadBalancerListener
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'PublicListener' ] ]

  FileSystemID:
    Description: File system ID
    Value: !Ref FileSystem
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'FileSystemID' ] ]  
  MountTargetOneID:
    Description: Mount target one ID
    Value: !Ref MountTargetOne
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'MountTargetOneID' ] ]
  MountTargetTwoID:
    Description: Mount target two ID
    Value: !Ref MountTargetTwo
    Export:
      Name: !Join [ '-', [ !Ref 'AWS::StackName', 'MountTargetTwoID' ] ]
